# 菜鸟修行之路----java虚拟机一：内存区域以及java对象

​        java虚拟机（JVM）时可以运行java代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域。

​      JVM是运行在操作系统之上的，它与硬件没有直接的交互。（java程序就是因为JVM的存在，拥有多平台运行特性（**一次编译，到处运行**））。

​      JVM主要包括以下内容：   

![1584322158412](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584322158412.png)

## 1.JVM内存区域

​       JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区
域【JAVA 堆、方法区】、直接内存。

![1584322576434](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584322576434.png)

通过上图可以得知，JVM内存主要分为以下3部分：

- **线程私有数据区域**：生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot
  VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的
  生/死对应)。
- **线程共享区域**：随虚拟机的启动/关闭而创建/销毁。
- **直接内存**：不是 JVM 运行时数据区的一部分, 但也会被频繁的使用。在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。

## 2.运行时数据区域

​         JVM载执行Java程序的过程中会把它所管理的内存划分为3个不同的数据区域（线程私有、线程共享、直接内存）。

​        **线程共享区域**随着虚拟机进程的启动而存在，**线程私有区域**则是依赖用户线程的启动和结束而建立和销毁。具体如下图所示：（其中程序计数器、Java虚拟机栈、本地方法栈为线程私有；Java堆、方法区位线程共享的内存区域。）

![1584323377971](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584323377971.png)

### 2.1程序计数器

- **程序计数器（Program Counter Register）**是一块较小的内存空间，可以看作是当前线程所执行的字节码的**行号指示器**。
- 程序计数器是一块**“线程私有”**的内存，如上文的图所示，每条线程都有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。这样设计使得在多线程环境下，线程切换后能恢复到正确的执行位置。
- 如果线程正在执行的是一个**Java方法**，这个计数器记录的是正在执行的**虚拟机字节码指令的地址**；若执行的是**Native方法**，则**计数器为空（Undefined）**（因为对于Native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“字节码指令的地址”的概念）。
- 程序计数器也是唯一一个在Java虚拟机规范中**没有**规定任何**OutOfMemoryError**情况的内存区域。

### 2.2 Java虚拟机栈

​    java虚拟机栈是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）
用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每一个方法从调用直至执行完成
的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

​    **栈帧（ Frame）**是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接
(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创
建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异
常）都算作方法结束。

​    **局部变量表****所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

​     Java虚拟机规范中在Java虚拟机栈区域规定2种异常：

- **StackOverflowError**：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。
- **OutOfMemoryError**：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。

### 2.3 本地方法栈

​     本地方法栈和 Java Stack(Java虚拟机栈) 作用类似, 区别是**虚拟机栈为执行 Java 方法服务, 而本地方法栈则为**
**Native 方法服务**, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

​     本地方法栈和虚拟机栈一样，也会抛出**StackOverflowError**和**OutOfMemoryError**异常。

   注：**java方法与native方法区别**

- java方法就是普通的方法（没有关键字native修饰的方法），native方法就是被关键字native修饰的方法，也叫做本地方法。
- native方法（本地方法）与平台相关，所有使用了本地方法的程序可移植性不高。
- native方法主要用于加载文件和动态链接库。并且java程序可以通过native方法（用c语言重写native方法）访问操作系统底层信息。

### 2.4 堆（类实例区）

- **Java堆（Heap）**是Java虚拟机所管理的内存中最大的一块，它**被所有线程共享的**，在虚拟机启动时创建。
- JJava堆**唯一的目的**是**存放对象实例**，几乎所有的对象实例都在这里分配内存，且每次分配的空间是**不定长**的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存**对象实例的属性值**，**属性的类型**和**对象本身的类型标记**等，**并不保存对象的方法（方法是指令，保存在Stack中）**。
- 在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。对象实例在Heap 中分配好以后，需要**在Stack中保存一个4字节的Heap 内存地址**，用来定位该对象实例在Heap 中的位置，便于找到该对象实例。

总结：**堆存放对象实例，栈中存放指向对象实例在堆中的内存地址。**

​      Java堆是垃圾收集器管理的主要区域，因此也被称为**“GC堆（Garbage Collected Heap）”**。从内存回收的角度看内存空间可划分为新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年代。具有如下：

![1584325056646](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584325056646.png)

#### 2.4.1 新生代（Young）

​        是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发

MinorGC 进行垃圾回收。

​       新生代又可细分为**Eden空间**、**From Survivor空间**、**To Survivor空间**，默认比例为8:1:1。

- **Eden空间**：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老
  年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行
  一次垃圾回收。
- **From Survivor空间**：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
- **To Survivor空间**：保留了一次 MinorGC 过程中的幸存者。

#### 2.4.2 老年代（OId）

​     主要存放应用程序中生命周期长的内存对象。在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。

#### 2.4.3 永久代（Perm）

​      永久代存储**类信息、常量、静态变量、即时编译器编译后的代码**等数据。

​       对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。  所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。

**注**：在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间
的本质和永久代类似，元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用**
**本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native
memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由
MaxPermSize 控制, 而由系统的实际可用空间来控制。

### 2.5 方法区

​    **方法区（Method Area）**与Java堆一样，是各个线程共享的内存区域。**Object Class Data(类定义数据)**是存储在方法区的，此外，**常量**、**静态变量**、**JIT编译后的代码**也存储在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 **Non-Heap**。

**运行时常量池（Runtime Constant Pool）**

- **运行时常量池（Runtime Constant Pool）**是方法区的一部分。**Class文件**中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池（Constant Pool Table）**，用于存放编译期生成的各种字面量和符号引用，**这部分内容将在类加载后进入方法区的运行时常量池存放**。
- 运行时常量池相对于Class文件常量池的另外一个重要特征是具备**动态性**，Java语言并不要求常量一定只有编译器才能产生，也就是**并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中**，此特性被开发人员利用得比较多的便是String类的`intern()`方法。

## 3.java对象

### 3.1对象的创建

对于java对象的创建，一般来说有以下4种方式：

- new关键字  :最常用以及最简单的对象创建方式。

```java
ObjectName obj = new ObjectName();
```

- 使用反射的Class类的newInstance（）方法：包括**Class**类的`newInstance()`方法和**Constructor**类的`newInstance()`方法（前者其实也是调用的后者）。

  ```java
  ObjectName obj = ObjectName.class.newInstance();
  //或者
  ObjectName obj = ObjectName.class.getConstructor.newInstance();
  ```

- 使用clone（）方法：使用`clone()`方法必须实现实现**Cloneable**接口，用`clone()`方法创建对象并不会调用任何构造函数。即我们所说的**浅拷贝**。

```java
ObjectName obj = obj.clone();
```

- 反序列化：反序列化让的类实现**Serializable**接口。当序列化和反序列化一个对象，JVM会创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。即我们所说的**深拷贝**。

```java
 try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) {
            ObjectName obj = ois.readObject();
        }

```

### 3.2 对象的创建过程

以第一种（new关键字）为例，学习JVM对于对象的创建过程，具体有如下步骤：

- 类加载检查
- 分配内存
- 初始化
- 设置对象头
- 执行init方法

#### 3.2.1 类加载检查

​     虚拟机遇到一条new指令时，首先将去检查**这个指令的参数是否能在常量池中定位到一个类的符号引用**，并且检查**这个符号引用代表的类是否已被加载、解析和初始化过的**，如果没有，则必须先执行相应的类加载过程，关于类加载机制和类加载器的内容参见《java虚拟机四：类加载机制》

#### 3.2.2 分配内存

​      在类加载检查通过后，虚拟机就将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务具体便等同于**从Java堆中划出一块大小确定的内存空间**，可以分如下两种情况讨论：

- **Java堆中内存绝对规整**：所有用过的内存都被放在一边，空闲的内存被放在另一边，**中间放着一个指针作为分界点的指示器**，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为**“指针碰撞”（Bump The Pointer）**。
- **Java堆中的内存不规整**：已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须**维护一个列表，记录哪些内存块是可用的**，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为**“空闲列表”（Free List）**。

**多线程下内存分配问题**：由于对象的创建在Java虚拟机中是非常频繁的行为，所以在多线程的场景下，使用单指针修改位置是线程不安全的。对于以上问题有以下2种解决方案：

- **对分配内存空间的动作进行同步**：虚拟机是采用**CAS**配上**失败重试**的方式保证更新操作的原子性。
- **把内存分配的动作按照线程划分在不同的空间之中进行**：每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲（TLAB ，Thread Local Allocation Buffer）**，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过**-XX:+/-UseTLAB**参数来设定。

#### 3.2.3 初始化

​      内存分配完成之后，虚拟机需要**将分配到的内存空间都初始化为零值（不包括对象头）**，如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。

#### 3.2.4 设置对象头

​      虚拟机要**设置对象的信息**（如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息）并存放在对象的**对象头（Object Header）**中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式

#### 3.2.5 执行init方法

​         在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——`<init>`方法还没有执行，所有的字段都还为零值。所以一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着执行`<init>`方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 3.3 对象的内存分布

对象在内存中存储的布局可以分为三块区域：

- **对象头（Header）**
- **实例数据（Instance Data）**
- **对齐填充（Padding）**

#### 3.3.1 对象头

对象头包括两部分信息：

- **对象自身的运行时数据 “Mark Word”**：如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等
- **类型指针**：类型指针即**对象指向它的类元数据的指针**，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### 3.3.2 实例数据

​       实例数据是对象真正存储的有效信息，也既是程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。

​       HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。

#### 3.3.3 对齐填充

对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。

### 3.4 对象的访问

java程序需要通过栈上的对象引用（reference，对象在堆中的具体存放地址）数据来操作堆上的具体对象。对于访问方式一般有以下2种：

- **句柄访问**：**Java堆中**划分出一块内存来作为**句柄池**，reference中存储的就是对象的句柄地址，而句柄中包含了**对象实例数据**与**类型数据**的各自的**具体地址信息**。如下图所示：

![1584328009312](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584328009312.png)

​      使用句柄访问的最大好处就是**reference中存储的是稳定的句柄地址**，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时**只会改变句柄中的实例数据指针，而reference本身不需要被修改**。

- 直接指针访问**：Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如下图所示：

![1584328049128](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584328049128.png)

​     用直接指针来访问最大的好处就是**速度更快**，它**节省了一次指针定位的时间开销**。





修行之路艰辛，与君共勉

​                                                                                                                        ----2020年3月 成都