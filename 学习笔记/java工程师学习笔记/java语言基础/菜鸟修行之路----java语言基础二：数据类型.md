# 菜鸟修行之路----java语言基础二：数据类型

## 1.数据类型

java的数据类型一般分为2类：基本数据类型和引用数据类型。

一般来说：基本数据类型存放的是数据本身，并且存放在虚拟机的栈中，然而引用数据类型在栈中存放的是数据的内存地址（堆中数据的存放地址），真实的数据存放在堆中。具体参见后文的《Java虚拟机》部分。

### 1.1**基本数据类型**

基本数据类型是系统所定义的，不可在划分的数据类型，所占内存大小固定。

java定义了8个基本数据类型，具体如下表所示：

| 类型             | 内存空间（字节） | 备注                                                         |
| ---------------- | ---------------- | ------------------------------------------------------------ |
| 字节（byte）     | 1                | 默认值为0，最小数据类型                                      |
| 短型（short）    | 2                | 默认值为0                                                    |
| 整型（int）      | 4                | 默认值为0                                                    |
| 长型（long）     | 8                | 默认值为0L                                                   |
| 单精度（float）  | 4                | 用于存储带小数点的数字（有效小数点只有6-7位），默认值0.0f，使用时后面加上f。 |
| 双精度（double） | 8                | 存储带小数点的数字，默认值0.0                                |
| 字符（char）     | 2                | 存储单个字符                                                 |
| 布尔（boolean）  | 1                | 用于判断真假，默认值为flase（有2个取值：flase，true）        |

**数据类型的转换**：

java允许转换变量的类型，并且提供2中转换方式：自动类型转换，强制类型转换。

**自动类型转换：**

基本数据类型按照精度高低进行由低到高的自动类型转换。

精度由低到高排序：

```java
byte<<short<<int<<long<<float<<double
```

实例：

```java
int a=10;
float b;
b=a;  //此时发生自动类型转换，b=10.0
```

**强制类型转换**：

当把高精度的变量赋值给低精度的变量时，必须使用强制类型转换。

转换格式如下：

```
 低精度变量 = （低精度变量的类型名） 高精度变量
```

实例：

```java
int a;
double b=3.15;

a=(int)b; //此时a=3，b的数据类型不变，但是使用强制类型转换会降价数据的精度。
```

### 1.2 引用数据类型

引用数据类型常常由多个基本数据类型组成。

java中包含了5中常见的引用数据类型：

- 类（class）：参见《面向对象基础》，https://blog.csdn.net/sumeriancer/article/details/104533187
- 接口（interface）：特殊的抽象类。
- 抽象类（abstract）：特殊的类。
- 数组（array）：相同类型变量的集合。
- 枚举（enum）：

#### 1.2.1**数组**

java中支持一维数组与多维数组，但是在内存中多维数组也是以一维数组的方式进行存储。多维数组可是说时逻辑上的概念，在内存中不存在明确的多维数组结构。

java中的数组都是静态的，在数组定义时就确定了数据的大小，

**一维数组定义**：

```java
//数据类型 数组名[] =new 数据类型[数组容量];
//或者
//数据类型 数组名[]={元素1，元素2，元素3，...}

int a[]= new int[10]
int b[]={1,2,3,4}

//数组长度。调用数组的length方法
a.lenth;
```

#### 1.2.2 枚举

​        枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型。

​        它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性

**枚举的简单应用**：使用enum关键字 定义枚举类型

```java
//定义
enum Day {
    MONDAY, TUESDAY, WEDNESDAY,THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

//使用
复制代码
public class EnumDemo {

    public static void main(String[] args){
        //直接引用
        Day day =Day.MONDAY;
    }

}

```

**枚举的经典应用**：单例模式的实现

```java
/**
 * 枚举单利
 */
public enum  SingletonEnum {
    INSTANCE;
    private String name;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name = name;
    }
}
```

单例模式具体分析与实现参见《单例模式的7种写法》

#### 1.2.3特殊的引用数据类型：String类

String类也是引用数据类型，并且它的底层时采用char数组实现的。

String类是final类，所有String类不能被继承，并且它的成员方法都默认为final方法。

所以：

**“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”**

字符串的常用方法：

| 方法            | 说明                                       |
| --------------- | ------------------------------------------ |
| length()        | 获取字符串的字符长度（char字符数组的长度） |
| equals()        | 判断2个字符串中的字符是否相等              |
| toLowerCase()   | 将字符串中的英文字符转换为小写             |
| toUpperCase（） | 将字符串中的英文字符转换为大写             |

简单实例：

```java
String str1="hello java";
str1.length();//获取str1的长度
String str2="hello";
boolean b1=str1.equals(str2); //判读str1与str2中的字符是否相等。

```

**拓展：**==和equals()的区别

**==**：用来直接比较两个对象的堆内存是否相等。

例如：

```java
int a=123;
int b=123;
system.out.println(a==b);
//结果为true,对于不变的基本数据类型以及String类型就可以通过==来比较他们值是否相等，他们的在内存中的地址时固定不变的。
```

所以总结来说：

- 如果作用于基本数据类型或者String类型的变量，则直接比较其存储的 “值”是否相等；
- 如果作用于引用类型的变量，则比较的是所指向的对象的地址

**equals方法**：

equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象。

在Object类型的equals方法是直接通过==来比较的。

- 在没有重写equals方法的前提下和==是没有任何区别，比较的是引用类型的变量所指向的对象的地址；
- 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。



**字符串与数值的转换：**

```java
//字符串转换为基本数据类型
String str="123";
int x=Integer.parseInt(str);
float n=Integer.parseFloat(str);
//或者
float n=Float.valueOf(str).floatValue();

//数值转换为整型
String str1=String.valueOf(122.4);

```



## 2.装箱与拆箱

​       为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
Java 为每个原始类型提供了包装类型：

| 原始类型 | 包装类型  |
| -------- | --------- |
| boolean  | Boolean   |
| char     | Character |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |

基本概念：

- 装箱就是自动将基本数据类型转换为包装器类型，装箱是通过调用包装器类的 valueOf 方法实现的。
- 拆箱就是自动将包装器类型转换为基本数据类型，拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。

简单实例：

```java

//自动装箱
Integer i = 8;
//自动拆箱
int n = i;
```

注意：

- 整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。
- 浮点型的包装类 valueOf 方法返回新的对象。
- 布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。

- 包含算术运算会触发自动拆箱，存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。所以在进行计算时，使用基本数据类型。





**后记：修行之路艰辛，与君共勉。**

​                                                                                                                                                             ---2020年春：成都